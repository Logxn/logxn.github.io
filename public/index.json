
[{"content":"","date":"13 August 2024","externalUrl":null,"permalink":"/","section":"Logan Thompson's Blog","summary":"","title":"Logan Thompson's Blog","type":"page"},{"content":"","date":"13 August 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\r0x1 - Introduction #\rI like playing video games of all different categories for example racing, moba, adventure or horror just to name a few. My favourite games however are shooter games, so much so that I started playing my first shooter Counter-Strike: Source when I was at the age of 13. However at the age of 13, just starting out with those kinds of games, I had to learn the hard way that I simply wasn\u0026rsquo;t skilled enough to compete with other players who were quite older than me at the time. So my younger self made the decision to start cheating in online video games and continued to do so for a couple of years until I was 18 or so.\nEven though I am not cheating in video games anymore, I have made quite a few contacts all around the cheating scene and continue to read and post in different forums that evolve around cheating. This is where I stumbled upon a thread where a user was discussing that he had received a HWID-ban after cheating in a video game and that he bought himself a HWID-spoofer and got banned again. Naturally a discussion started about which HWID-spoofer is the best and where to buy them from.\nBut what exactly is HWID, what is an HWID-ban and what is a HWID-spoofer you might ask. HWID is the abbreviation for Hardware ID and is essentially a generated identifier of different components of you system. Now there are many different identifiers you could possibly choose from - but there are also some pretty crappy ones as well, since you want to generate an identifier that is unique to the person playing. For example a bad identifier would be the combination out of CPU Model + GPU Model because that would just give you an identifier like i7 13700k + RTX 4070ti and that surely isn\u0026rsquo;t unique to every player. However a better example would be taking the serialnumber of the cpu + the serialnumber of the gpu, because these are unique to every player.\nInfo!\nThere are better identifiers that can be used for HWIDs but I\u0026rsquo;ll keep it simple.\rThese generated identifiers are then sent back to the game developers. Once they catch you cheating they can permanently ban your PC from playing the game until you switch out the affected components (that is if they have chosen an identifier which you can easily replace) and this is commonly referred to as a HWID-ban. To circumvent these kinds of bans, cheaters often use HWID-spoofers which do what the name suggests. However because many games use different kinds of identifiers you either need different spoofers or one spoofer that does it all and that subsequently means that prices for these are high (some sell for $100 for 48h access).\n0x2 - Who is EUCHEATS #\rGoing back to the forum discussion, a user named EUCHEATS advertised their own HWID spoofer. It didn\u0026rsquo;t take long until another user noted that the author should resort to HWID-spoofers of companys that have a known and good reputation instead of someone calling themselves \u0026ldquo;EUCHEATS\u0026rdquo;. EUCHEATS became offended by that an responded with the following:\nHow can we be scammers \u0026amp; not trusted? and our post didn\u0026rsquo;t get deleted from [3rd party site outside of the cheating forum] since 2022?\nFurthermore they stated:\nGo google us! or Find us on YouTube! We sell cheats since 2019 \u0026amp; no one reported/called us scammers\u0026hellip; We were promoted by these youtubers:\nAnd then they listed a bunch of YouTube videos of advertisers promoting the cheats of EUCHEATS.\nI saw this as a challenge and decided to see for myself how trustworthy they really are.\n0x21 - Their Website #\rUpon inspecting the website of EUCHEATS I could instantly see their advertisment for different cheats. Noticably their website was also filled with different grammar errors, while I don\u0026rsquo;t expect a blog post to be free of grammar errors for non native english speakers, I\u0026rsquo;d expect a company or individual selling different products to produce a website that is free from grammar mistakes.\nUpon inspecting their footer, I could also notice the same grammar mistakes and poorly written English. Even more noticable was the copyright disclaimer produced by their forum software XenForo which includes the timespan 2010-2017, which leads me to believe that either a) the software hasn\u0026rsquo;t been updated in a while and most likely prone to some serious vulnerabilities or b) the software has been pirated, which is more likely, since a XenForo license isn\u0026rsquo;t exactly cheap.\nHowever, I won\u0026rsquo;t judge a book by it\u0026rsquo;s cover and I discovered there was a free version of their cheat that anyone can download and try IF you register on their forums - and that\u0026rsquo;s exactly what I did.\n0x22 - The Free Cheat Advertisement #\rAs you can see the cheat in question is a free cheat for the game CS2 (aka: Counter-Strike formerly Counter-Strike: Global Offensive). Their advertisement is quite funny, because they state the following:\nEucheats provides one of the longest running Undetected free CS2 cheats in the scene, our cheats are still undetected by VAC in 2024.\nIt is a weird statement to make when no one in the cheating scene has ever heard from you and there are - apart from the YouTube advertisements these YouTubers do for a cheap price or a free copy of the cheat - basically no reviews of the software in question. Further more they state:\nOur Free CS2 Hack has too many CS2 Features rather than other cheat providers. EUCheats provides users the best experience to beat their opponents and of course, our CS2 Hacks are 100% free!\nThis is quite an exaggeration because the features they provide in the free cheat (ESP aka Wallhack, Aimbot, Bunnyhop, Rank Reveal) are the most common and basic features of a cheat for CS2 with the last feature being a straight up lie because it has already been patched in Counter-Strike: Global Offensive (CSGO).\nSo let\u0026rsquo;s download and inspect this free cheat shall we? üïµÔ∏è\n0x3 - Their Free Cheat #\rUpon downloading their cheat my Windows Defender greeted me with all kinds of virus warnings and because I don\u0026rsquo;t trust no name cheat providers to not infect their software with malware I booted up my Windows VM to take a closer look.\n0x31 - Initial Recon #\rThe downloaded archive EUCHEATS-FREE.rar contained a file called ASUSLEDs.exe. A little spoiler: This file will be the login client and loader for the cheat. Some of you readers that might have some IT-Security background might know that malware tends to use names for executables that make them less obvious, but the same can be said for cheat developers. A while back this was sufficient for avoiding super simple anti-cheats that simply scanned for names of running executables. Most present day cheat developers will resort to executable names that are filled with random characters which are generated per download or don\u0026rsquo;t even try to hide the name of the loader at all.\nUpon inspecting the executable with Detect it Easy we can see that the file was protected with Themida/Winlicense(3.XX). Themida is a protection system against Reverse Engineering and if the newest version was used could potentially be a pain in the ass to remove said protection. Luckily for us though a most likely pirated version of the product was used (as licenses cost $199) and we can resort to a tool called mal-unpack.\nAs you can see this tool took only around 2 seconds to unpack the whole executable effectively removing the Themida Protector.\nAfter inspecting the unpacked executable we can find new key informations. First of all the executable in question is also protected by a tool called .NET REACTOR (guessed v4.8-4.9). Again we can assume that a pirated version of this software was used because the current version of .NET Reactor is v6.9.8.0 and the licensing price also starts at $199. Fortunately for us there is a tool called de4dot which has been modded tons of times to include support for various different protectors. The next and final key information we can gather from this newly unpacked exectuable is that it has been written in a .NET programming language (most likely C#). Cleaned and unpacked .NET files are the easiest files to reverse engineer because you almost restore the written code completely instead of relying on pseudo-code when it comes to other languages.\nSo lets deobfuscate this binary.\nAfter deobfuscating with de4dot we can see only two protections are left. This guy really used all tools available on the internet to stop people from reverse engineering this piece of software. However this should be enough to take a first look with dnSpy.\n0x32 - Reverse Engineering #\rThis piece of code you see is the entry point. I will break it up in smaller parts, rename some function names, variables and explain it.\n// PSEUDO-CODE ! private void timer_tick(object sender, EventArgs e) { index++; if (index \u0026gt;= 10) { timer.stop(); string text = new WebClient().DownloadString(\u0026#34;https://eucheats.com/FREE/up.txt\u0026#34;); if (text.Contains(\u0026#34;5.2\u0026#34;)) { int button_pressed = (int)MessageBox.Show(\u0026#34;EUCHEATS Premium version is now out! Stay safe \u0026amp; checkout our paid hack it\u0026#39;s only 5‚Ç¨ per month.\\r\\n\\r\\nDo you want to buy it?\u0026#34;, \u0026#34;PREMIUM VERSION\u0026#34;, MessageBoxButtons.YesNo); if (button_pressed == 7) // Button No { Process.Start(\u0026#34;https://eucheats.com/pages/premium-csgo-cheats/\u0026#34;); picture.Hide(); Class2.Class3_0.Form2.Show(); return; } if (button_pressed == 6) // Button Yes { Process.Start(\u0026#34;https://eucheats.com/account/upgrades\u0026#34;); picture.Hide(); Class2.Class3_0.Form2.Show(); return; } } } } So first of all when you start the loader you are greeted with a picture of their logo. In this peace of code you can see that there is a timer_tick() function, that will get executed every second. For every second we have a variable called index which starts at 0 and counts up until it reaches 10. This simply is for making the user think the software is actually loading even if there is nothing to load üôÑ. Bad Code Quality!\nHere you can observe the first minor flaw in the software because the check if index \u0026gt;= 10 is immediatly followed by a timer.stop(). So if the timer executes every second and stops at 10 seconds there is no need for a \u0026gt;= check. A simple index == 10 check would\u0026rsquo;ve been sufficient.\nBut don\u0026rsquo;t worry this probably won\u0026rsquo;t be the last flaw we are covering.\rAfterwards the software makes a request to a up.txt which is located on the website of EUCHEATS and simply contains a decimal number which should represent the current version of the cheat. If the number still matches 5.2 it will show a popup asking if you want to buy the cheat. Doesn\u0026rsquo;t matter what you answer in this popup, a wbesite where you can buy the cheat will be opened. If the popup was answered the fake loading screen will be hidden and a new window will be presented.\nIf the version number doesn\u0026rsquo;t match the hardcoded number the cheat will close and the website of the free cheat will be opened, so a new version can be downloaded.\nThis is the disassembled code that gets loaded if the popup was dismissed and the cheats version number matches with the one of the server. What the author of the code intended to do is generate a HWID for himself. This is logical because cheat developers are interested in money and they want to prevent people sharing the cheat with their friends. So once again a HWID will be used to identify a unique user and to lock one PC to the registered forum account. The author intends to access the Windows Management Instrumentation which is a API provided by Windows that has every information about your PC (for example hardware information) stored in a database. Furthermore the author of the code intends to read the ProcessorId which holds information about what capabilities the CPU has. Info!\nAs we learned previously this isn\u0026rsquo;t a good way to generate a HWID, because the capabilities of a processor is not necessarily unique per user.\rThe processId is supposed to be stored in a label called label7 and should be hidden from the user.\nCode Flaw!\nHere you can observe the second code flaw. I mentioned a couple of times that the code author intends to read the processorId. Unfortunately the code is wrong as it misses the namespace of the database. Therefore the software presents an error warning when starting up and label7 will never hold the requested information or let alone be hidden.\nThe error message (in German) as explained above.\nHere you can see that label7 never gets hidden.\nHere you can see the main menu of the free cheat. It has two tabs \u0026ldquo;Login\u0026rdquo; and \u0026ldquo;Confirmation\u0026rdquo;. Confirmation has the same layout as the login tab and is used to set the HWID of a given user. This we will inspect next.\nAs you can see from the disassembled code above, the loader makes a request to the backend of EUCHEATS, specifically handler.php and passes the supplied username, password and HWID. This triggers the registration of a user in another database that is not linked to the forum account, so why even make a forum account in the first place and a loader if you don\u0026rsquo;t use it properly? Since I stated above that the HWID never gets generated because of poorly written code, the request will always include \u0026amp;hwid=label7 which means that every user registers with the same HWID completely defeating the purpose of a HWID check in the first place.\nBad Code Quality!\nIn the code above you might observe the check that gets triggered before the error message \u0026ldquo;User Not Found!\u0026rdquo; is triggered. This check is unnecessarly complicated because it uses multiple functions (IsNullOrWhitespace() \u0026amp; CompareString()) to check wether invalid entries were made. However IsNullOrWhitespace() is sufficient to check if a string is either null, empty or full of whitespaces. Furthermore the username will not be compared against any existing forum accounts. Instead it will create an entry in another database which is then used by the login tab.\r","date":"13 August 2024","externalUrl":null,"permalink":"/posts/the-downfall-of-eucheats/","section":"Posts","summary":"0x1 - Introduction #\rI like playing video games of all different categories for example racing, moba, adventure or horror just to name a few.","title":"The Downfall Of EUCHEATS","type":"posts"},{"content":"Type: Challenge Category: Reversing Difficulty: Very Easy Solves: 3655 In this post we will be looking at a very simple encryptor and how to break it!\n0x1 - RECON #\rBefore we begin reversing the encryptor we have to see what we are dealing with.\nIdentifying the file type #\rA quick call to file reveals that the encrypt file is a 64Bit Linux executable. Now unfortunately that won\u0026rsquo;t run natively on my M3 MacBook Pro. But for now we don\u0026rsquo;t yet know if we have to run this file - chances are we can simply reverse engineer the file and build a decryptor without ever running it.\nStrings #\rCalling strings reveals some interesting references:\nsrand\rfopen\rftell\rtime This is all the recon I will do for now, time to load the file with Ghidra!\n0x2 REVERSE #\rThis is what we are greeted with when loading encrypt into Ghidra and decompiling the main function. As you can see some of the variables have already been renamed and comments were added by me.\nDont worry if you can\u0026rsquo;t make anything of it. Lets break it down.\nReading the flag #\rflag_pointer = fopen(\u0026#34;flag\u0026#34;,\u0026#34;rb\u0026#34;); The encryptor first calls the function fopen which takes two arguments filename and mode. Looking at the function call the first argument is obvious, the file that the encryptor reads is called flag but the second argument might not be so obvious at first. The file flag is opened with the mode rb where r stands for read and b for binary \u0026ndash; in simple terms: \u0026ldquo;read the file as binary\u0026rdquo;. This function will return a pointer in memory where the file is stored and stores it in a variable, which I called file_pointer.\nfseek(flag_pointer,0,2); Next the encryptor calls the function fseek which takes three arguments stream(which is a pointer to a file) offset and origin. In short this function sets the position indicator of a file stream. Imagine if you have opened a textfile with your favorite editor. The curser position in your editor is the same as the position indicator of a file stream. The third argument of fseek is origin and defines where the cursor should be set. In this case the number 2 is the integer representation of the C++ constant SEEK_END, which means that the cursor is placed at the end of the file. The second argument offset tells the function how many bytes the cursor should move from origin. So since origin is the end of the file and offset is 0 the cursor is supposed to remain at the end of the file.\nTL;DR: The cursor in our file stream file_pointer is now at the end of the file.\nflag_size = ftell(flag_pointer); Next the encryptor calls the function ftell which takes only one argument stream (in our case: file_pointer). When the stream is a binary stream (which it is, since the encryptor opened it with the flags rb) the function returns the numbers of bytes the position indicator has moved from the beginning of the file. This is the method how the encryptor reads how big the file is, thats why I named the variable of the return value flag_size.\nfseek(flag_pointer,0,0); mem_ptr = malloc(flag_size); Now the encryptor moves the position indicator back to the beginning of the file (Note: This is because origin is now 0 too which translates to SEEK_SET).\nAfterwards the encryptor allocates space in memory using malloc. The size it allocates is the same size as the flag. The return value will be a pointer to the allocated space in memory.\nfread(mem_ptr,flag_size,1,flag_pointer); fclose(flag_pointer); To finish reading the flag the encryptor utilizes fread which takes four arguments ptr, size, count and stream. The first argument ptr tells the function where the read content should be saved. In our case that\u0026rsquo;s the memory the encryptor has just allocated for us. Next size tells the function how many bytes should be read. The third parameter count tells the function how many elements we are dealing with. Each element has a size of the previous argument size. In our case we are dealing with flag_size * 1 bytes that should be read \u0026ndash; in simple terms: read the flag exactly once. The last argument stream tells the function where we want to read from.\nFinally the stream to the flag file is closed via fclose.\nTL;DR: Read the flag and save it in memory.\nEncryption time! #\rtVar1 = time((time_t *)0x0); timestamp_seed = (uint)tVar1; srand(timestamp_seed); It is now time to look at how the encryption actually works, so we can make a plan on how to decrypt the encrypted flag within the challenge files. Firstly the encryptor calls time which takes exactly one argument time (which is a pointer to time_t). Normaly the function would take a specific time and date, but in our case the decompiler shows 0x0 which essentially is a NULL-Pointer. This means that the argument is not used. Because of this the function will return the seconds passed since 00:00, Jan 1 1970 UTC. The returned seconds are then saved in a variable I called timestamp_seed.\nNext the function calls srand which takes exactly one argument seed. As we can see in Ghidra\u0026rsquo;s decompiler, the encryptor passes the received timestamp as seed. It is important to know, that srand initializes a pseudo-number-generator. After that we could call rand() a number of times to receive different random numbers. If we know the value of the seed we can always generate the same numbers on almost any machine, in the same order.\nThis will be the part we will try to exploit in the future! üòà\nfor (i = 0; i \u0026lt; (long)flag_size; i = i + 1) { pseudo_random = rand(); *(byte *)((long)mem_ptr + i) = *(byte *)((long)mem_ptr + i) ^ (byte)pseudo_random; pseudo_random2 = rand(); pseudo_random2 = pseudo_random2 \u0026amp; 7; *(byte *)((long)mem_ptr + i) = *(byte *)((long)mem_ptr + i) \u0026lt;\u0026lt; (sbyte)pseudo_random2 | *(byte *)((long)mem_ptr + i) \u0026gt;\u0026gt; 8 - (sbyte)pseudo_random2; } This is where the fun stuff is happening, so let\u0026rsquo;s look closely what happens.\nThe encryptor runs a loop starting at 0 and counts up until it reaches the size of the original flag. The current count is stored in i. A supposedly random number is generated via rand and stored in what I called pseudo_random It reads the n-th byte of the flag it copied into memory (it does this by doing mem_ptr + i. So if i = 0 it reads the first byte, i = 1 the second and so on). The read byte is then XORed with the first random number generated. A second supposedly random number is generated via rand. The second generated number is compared with the number 7 using Bitwise AND the result will be saved in pseudo_random2 again. The encrypted bytes get saved in a three step process The previously with XOR encrypted bytes are bitshifted left by the number stored in pseudo_random2 The result of the bitshift is then being compared trough Bitwise OR with yet another bitshift calculation. This time the bits are shifted to the right by 8 - pseudo_random2 positions. enc_pointer = fopen(\u0026#34;flag.enc\u0026#34;,\u0026#34;wb\u0026#34;); fwrite(\u0026amp;timestamp_seed,1,4,enc_pointer); fwrite(mem_ptr,1,flag_size,enc_pointer); fclose(enc_pointer) Finally the encrypted bytes are saved to flag.enc. The encryptor utilizes fopen once again, this time using the filename flag.enc and the mode wb which unlike above stands for \u0026ldquo;write bytes\u0026rdquo;, receiving yet again a pointer to a file in memory (Note if the file doesn\u0026rsquo;t exist, it will be created on disk).\nNext we see two calls to fwrite which takes four arguments ptr, size, count, stream just like fread. The encryptor writes the timestamp_seed to the first four bytes (size * count = 1 * 4) of flag.enc. With the second call to fwrite the encryptor writes the encrypted bytes stored in mem_ptr to the encrypted file. Finally the handle to the encrypted flag file flag.enc is closed.\nThat\u0026rsquo;s it. That\u0026rsquo;s all that the decryptor does.\n0x3 DECRYPT #\rIf you understood every step and mathematical operation listed in Encryption time! you might have an idea on how we could be able to decrypt the file.\nFirstly we need to control the timestamp_seed and make sure it\u0026rsquo;s the same as during the encryption, so we can generate the same \u0026ldquo;random\u0026rdquo; numbers. Luckily the timestamp was written to the first 4 bytes of the encrypted flag file flag.enc so let\u0026rsquo;s extract it using python!\nfrom datetime import datetime with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;) as f: timestamp = int.from_bytes(f.read(4), byteorder=\u0026#39;little\u0026#39;) print(f\u0026#39;Timestamp used: {timestamp} ({datetime.fromtimestamp(timestamp)})\u0026#39;) As we can see, we have sucessfully read the timestamp that was saved in flag.enc and we now know that the flag was encrypted on 05:04:58, June 1st, 2022.\nNext it\u0026rsquo;s time to read the remaining data by moving the cursor of the file 4 bytes ahead since the first 4 bytes are occupied by the timestamp.\nwith open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;) as f: timestamp = int.from_bytes(f.read(4), byteorder=\u0026#39;little\u0026#39;) # Move after timestamp f.seek(4) encrypted_flag = f.read() print(f\u0026#39;Timestamp used: {timestamp} ({datetime.fromtimestamp(timestamp)})\u0026#39;) print(f\u0026#39;Encrypted flag (bytes): {encrypted_flag}\u0026#39;) We have successfully read the encrypted bytes. But we don\u0026rsquo;t know if we have read correctly, until we start the decryption process so let\u0026rsquo;s go.\nIf you have understood the mathematical operators the encryptor used from the previous chapter, you might know that all we have to do is repeat all steps but in reverse and inverted. So if bits were right shifted, we shift them left and vice versa. To revert the XOR operation we simply take the byte and XOR it with the same value again!\nfrom ctypes import CDLL, c_uint # We need this in order to use the srand library provided by the C-Language # and not by python since they are different and wont result in the same values used by the encryptor. libc = CDLL(\u0026#39;libc.so.6\u0026#39;) # Initialize the pseudo-random generator with the timestamp libc.srand(c_uint(timestamp)) decrypted = bytearray() for byte in bytearray(encrypted_flag): # Generating the same \u0026#34;random\u0026#34; numbers as the encryptor # Now that wouldn\u0026#39;t make the generated numbers truly random, would it? pseudo_random = libc.rand() \u0026amp; 0xFF # \u0026amp; 0xFF makes sure that pseudo_random is exactly 1 byte long pseudo_random_2 = libc.rand() \u0026amp; 7 # Encryptor: *(byte *)((long)mem_ptr + i) \u0026lt;\u0026lt; (sbyte)pseudo_random2 | *(byte *)((long)mem_ptr + i) \u0026gt;\u0026gt; 8 - (sbyte)pseudo_random2; # As you can see we invert the shifting. left to right and right to left. tmp = (byte \u0026gt;\u0026gt; pseudo_random_2) | (byte \u0026lt;\u0026lt; 8 - pseudo_random_2) # again make sure that we have exactly one byte tmp \u0026amp;= 0xFF # XOR the encrypted byte with the pseudo_random again to decrypt the byte tmp ^= pseudo_random decrypted.append(tmp) print(f\u0026#39;Decrypted flag: {decrypted.decode(\u0026#34;utf-8\u0026#34;)}\u0026#39;) And that\u0026rsquo;s it! We have sucessfully decrypted the flag by reverting all the steps from the encryptor. ü•≥\nFull Code:\nfrom ctypes import CDLL, c_uint from datetime import datetime with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;) as f: timestamp = int.from_bytes(f.read(4), byteorder=\u0026#39;little\u0026#39;) # Move after timestamp f.seek(4) encrypted_flag = f.read() print(f\u0026#39;Timestamp used: {timestamp} ({datetime.fromtimestamp(timestamp)})\u0026#39;) print(f\u0026#39;Encrypted flag (bytes): {encrypted_flag}\u0026#39;) libc = CDLL(\u0026#39;libc.so.6\u0026#39;) libc.srand(c_uint(timestamp)) decrypted = bytearray() for byte in bytearray(encrypted_flag): pseudo_random = libc.rand() \u0026amp; 0xFF pseudo_random_2 = libc.rand() \u0026amp; 7 tmp = ((byte \u0026gt;\u0026gt; pseudo_random_2) | (byte \u0026lt;\u0026lt; 8 - pseudo_random_2)) \u0026amp; 0xFF tmp ^= pseudo_random decrypted.append(tmp) print(f\u0026#39;Decrypted flag: {decrypted.decode(\u0026#34;utf-8\u0026#34;)}\u0026#39;) All in all I would rate this challenge with Easy instead of Very Easy since it requires some prior knowledge to bitwise operators.\nThat\u0026rsquo;s all for now, hopefully you\u0026rsquo;ll join me for the next challenge soon! :)\n","date":"18 June 2024","externalUrl":null,"permalink":"/posts/htb-simple-encryptor/","section":"Posts","summary":"Type: Challenge Category: Reversing Difficulty: Very Easy Solves: 3655 In this post we will be looking at a very simple encryptor and how to break it!","title":"HackTheBox - Simple Encryptor","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]